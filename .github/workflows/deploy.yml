name: CI/CD for PAPER Branch

on:
  push:
    branches:
      - PAPER
      - LIVE

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  GCP_HOST: ${{ secrets.GCP_HOST }}
  GCP_USER: ${{ secrets.GCP_USER }}
  GH_TOKEN: ${{ secrets.GH_TOKEN }}
  SKIP_PUSH: true
  CREATE_RELEASE: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKERHUB_USERNAME }}
        password: ${{ env.DOCKERHUB_TOKEN }}

    - name: Build and push all Docker images
      run: |
        for service in DBManager cacheManager capitalManager alertingService strategyUtils LiveMarketListener orderListner orderSimulator MarketSimulator strategies/sma; do
          name=$(basename "$service" | tr '[:upper:]' '[:lower:]')

          # Trova il file .js con lo stesso nome della cartella (confronto in lowercase)
          version_file=$(find "$service" -type f -name "*.js" | while read -r f; do
            file_base=$(basename "$f" .js | tr '[:upper:]' '[:lower:]')
            if [[ "$file_base" == "$name" ]]; then
              echo "$f"
              break
            fi
          done)

          if [[ -z "$version_file" ]]; then
            echo "âš ï¸  Nessun file corrispondente trovato in $service, salto versione..."
            continue
          fi

          version=$(grep MODULE_VERSION "$version_file" | head -n1 | sed -E "s/.*=[[:space:]]*['\"']([^'\"']+)['\"'].*/\1/" | tr -d '\r')
          echo "ðŸ”§ Building $name from $version_file with version $version..."

          if [ "$SKIP_PUSH" != "true" ]; then
            docker build -t $DOCKERHUB_USERNAME/$name:latest -t $DOCKERHUB_USERNAME/$name:$version -f $service/Dockerfile .
            docker push $DOCKERHUB_USERNAME/$name:latest
            docker push $DOCKERHUB_USERNAME/$name:$version
          fi
        done

    - name: Setup SSH key
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Creazione release su github
      run: |
        if [ "$CREATE_RELEASE" != "false" ]; then
          TAG=$(jq -r .version release.json)
          TITLE=$(jq -r .note release.json)

          # Genera le note
          bash ./generate-release-notes.sh

          # Crea la release (gh CLI deve essere installata)
          gh release create "$TAG" \
            --title "$TITLE" \
            --notes-file release-notes.md \
            --target PAPER \
            --repo $GITHUB_REPOSITORY
          fi

    - name: Generate .env for server
      run: |
        echo "LOG_LEVEL=${{ vars.LOG_LEVEL }}" > .env
        echo "ENV_NAME=${{ github.ref_name }}" >> .env
        echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
        echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
        echo "MYSQL_DATABASE=${{ vars.MYSQL_DATABASE }}" >> .env
        echo "MYSQL_USER=${{ vars.MYSQL_USER }}" >> .env
        echo "ALPACA_MARKET_FEED=${{ vars.ALPACA_MARKET_FEED }}" >> .env
        echo "ENV_MARKET=${{ vars.ENV_MARKET }}" >> .env
        echo "ENV_ORDERS=${{ vars.ENV_ORDERS }}" >> .env
        echo "ENV_TRADING=${{ vars.ENV_TRADING }}" >> .env
        echo "NETWORK=${{ vars.NETWORK }}" >> .env

    - name: Copy .env to server
      run: |
        scp -o StrictHostKeyChecking=no .env $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/.env

    - name: Deploy updated DB
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST "ENV_NAME=${{ github.ref_name }} GH_TOKEN=${GH_TOKEN} bash -s" <<'EOF'
          mkdir -p ~/deploy
          cd ~/deploy
          echo "ðŸ“¥ Scarico docker-compose.yml..."
          curl -s -H "Authorization: token $GH_TOKEN" -o docker-compose.yml https://raw.githubusercontent.com/expovin/trading-system/refs/heads/PAPER/docker-compose.yml

          echo "ðŸ“¥ Scarico db_update.sql..."
          curl -H "Authorization: token $GH_TOKEN" -s -o db_update.sql https://raw.githubusercontent.com/expovin/trading-system/refs/heads/PAPER/db/db_update.sql

          if ! grep -q "services:" docker-compose.yml; then
            echo "âŒ docker-compose.yml non valido o non trovato!"
            cat docker-compose.yml
            exit 1
          fi

          LOWER_PROJECT_NAME=$(echo "$ENV_NAME" | tr '[:upper:]' '[:lower:]')
          echo "Environment: $ENV_NAME"
          echo "GitHub Token Length: ${#GH_TOKEN}"
          echo "Project Name: ${LOWER_PROJECT_NAME}"

          docker compose -p "$LOWER_PROJECT_NAME" down
          docker compose pull
          docker compose --env-file .env -p "$LOWER_PROJECT_NAME" up -d --remove-orphans mysql

          max_attempts=10
          attempt=1

          echo "â³ Attendo che mysql sia healthy..."
          until docker compose -p "$LOWER_PROJECT_NAME" ps --filter "status=running" | grep mysql | grep healthy; do
            if [ $attempt -ge $max_attempts ]; then
              echo "âŒ ${CONTAINER} non Ã¨ diventato healthy dopo ${max_attempts} tentativi. Interrompo."
              exit 1
            fi
            echo "âŒ› ${CONTAINER} non ancora pronto, tentativo ${attempt}/${max_attempts}, riprovo tra 2s..."
            sleep 2
            ((attempt++))
          done
          echo "âœ… mysql Ã¨ healthy" 
        EOF

    - name: Copy DB migration scripts to server
      run: |
        scp -o StrictHostKeyChecking=no -r db apply-db-updates.sh $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/

    - name: Run DB migrations on server
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << EOF
          cd ~/deploy
          bash apply-db-updates.sh ${{ github.ref_name }}
        EOF

    - name: Crea shared cache volume se non esistente
      run: |
        if ! docker volume ls --format '{{.Name}}' | grep -q '^shared_cache_data$'; then
          echo "ðŸ› ï¸  Creo volume condiviso shared_cache_data..."
          docker volume create shared_cache_data
        else
          echo "âœ… Volume shared_cache_data giÃ  esistente, proseguo..."
        fi
        EOF


    - name: Start all other container
      run: |
        docker compose --env-file .env -p "$LOWER_PROJECT_NAME" up -d --remove-orphans

    - name: Cleanup .env on server
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << 'EOF'
          rm -f ~/deply/.env
        EOF