name: CI/CD for PAPER Branch

on:
  push:
    branches:
      - PAPER
      - LIVE

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  GCP_HOST: ${{ secrets.GCP_HOST }}
  GCP_USER: ${{ secrets.GCP_USER }}
  GH_TOKEN: ${{ secrets.GH_TOKEN }}
  SKIP_PUSH: false
  CREATE_RELEASE: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKERHUB_USERNAME }}
        password: ${{ env.DOCKERHUB_TOKEN }}

    - name: üö¶ Verifica modalit√† di deploy su LIVE
      run: |
        BRANCH_NAME="${{ github.ref_name }}"
        EVENT_NAME="${{ github.event_name }}"
        SOURCE_BRANCH="${{ github.event.pull_request.head.ref }}"
        TARGET_BRANCH="${{ github.event.pull_request.base.ref }}"

        echo "üîç Branch: $BRANCH_NAME, Evento: $EVENT_NAME, PR Source: $SOURCE_BRANCH, PR Target: $TARGET_BRANCH"

        if [[ "$BRANCH_NAME" == "LIVE" ]]; then
          if [[ "$EVENT_NAME" != "pull_request" ]]; then
            echo "‚ùå Deploy su LIVE permesso solo tramite Pull Request da PAPER"
            exit 1
          fi

          if [[ "$SOURCE_BRANCH" != "PAPER" || "$TARGET_BRANCH" != "LIVE" ]]; then
            echo "‚ùå Solo PR da PAPER a LIVE sono consentite"
            exit 1
          fi
        fi

        echo "‚úÖ Controllo superato, proseguo con il deploy..."


    - name: Build and push all Docker images
      run: |
        if [[ "${{ github.ref_name }}" == "LIVE" ]]; then
          echo "‚ö†Ô∏è  Skip build e push: il branch LIVE deve solo eseguire il deploy di immagini gi√† pubblicate."
          exit 0
        fi

        for service in DBManager cacheManager capitalManager alertingService strategyUtils LiveMarketListener orderListner orderSimulator MarketSimulator strategies/sma; do
          name=$(basename "$service" | tr '[:upper:]' '[:lower:]')

          # Trova il file .js con lo stesso nome della cartella (confronto in lowercase)
          version_file=$(find "$service" -type f -name "*.js" | while read -r f; do
            file_base=$(basename "$f" .js | tr '[:upper:]' '[:lower:]')
            if [[ "$file_base" == "$name" ]]; then
              echo "$f"
              break
            fi
          done)

          if [[ -z "$version_file" ]]; then
            echo "‚ö†Ô∏è  Nessun file corrispondente trovato in $service, salto versione..."
            continue
          fi

          version=$(grep MODULE_VERSION "$version_file" | head -n1 | sed -E "s/.*=[[:space:]]*['\"']([^'\"']+)['\"'].*/\1/" | tr -d '\r')
          echo "üîß Building $name from $version_file with version $version..."

          if [ "$SKIP_PUSH" != "true" ]; then
            docker buildx build \
              --push \
              --tag $DOCKERHUB_USERNAME/$name:latest \
              --tag $DOCKERHUB_USERNAME/$name:$version \
              --cache-from=type=registry,ref=$DOCKERHUB_USERNAME/$name:cache \
              --cache-to=type=registry,ref=$DOCKERHUB_USERNAME/$name:cache,mode=max \
              -f $service/Dockerfile \
              .
          fi
        done

    - name: Setup SSH key
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Install jq
      run: sudo apt-get update && sudo apt-get install -y jq

    - name: Creazione release su github
      run: |
        if [ "${{ github.ref_name }}" == "LIVE" ] && [ "$CREATE_RELEASE" != "false" ]; then
          TAG=$(jq -r .version release.json)
          TITLE=$(jq -r .note release.json)

          # Genera le note
          bash ./generate-release-notes.sh

          # Crea la release (gh CLI deve essere installata)
          gh release create "$TAG" \
            --title "$TITLE" \
            --notes-file release-notes.md \
            --target PAPER \
            --repo $GITHUB_REPOSITORY
          else
            echo "üö´ Skip: Creazione release abilitata solo su LIVE o CREATE_RELEASE=false"
          fi

    - name: Generate .env for server
      run: |
        echo "LOG_LEVEL=${{ vars.LOG_LEVEL }}" > .env
        echo "ENV_NAME=${{ github.ref_name }}" >> .env
        echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
        echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
        echo "MYSQL_DATABASE=${{ vars.MYSQL_DATABASE }}" >> .env
        echo "MYSQL_USER=${{ vars.MYSQL_USER }}" >> .env
        echo "ALPACA_MARKET_FEED=${{ vars.ALPACA_MARKET_FEED }}" >> .env
        echo "ENV_MARKET=${{ vars.ENV_MARKET }}" >> .env
        echo "ENV_ORDERS=${{ vars.ENV_ORDERS }}" >> .env
        echo "ENV_TRADING=${{ vars.ENV_TRADING }}" >> .env
        echo "NETWORK=${{ vars.NETWORK }}" >> .env

    - name: Add .env with container versions from JS files
      run: |
        echo "üìù Genero .env con le versioni dei container dai file .js..."

        for service in DBManager cacheManager capitalManager alertingService strategyUtils LiveMarketListener orderListner orderSimulator MarketSimulator strategies/sma; do
          name=$(basename "$service" | tr '[:upper:]' '[:lower:]')

          version_file=$(find "$service" -type f -name "*.js" | while read -r f; do
            file_base=$(basename "$f" .js | tr '[:upper:]' '[:lower:]')
            if [[ "$file_base" == "$name" ]]; then
              echo "$f"
              break
            fi
          done)

          if [[ -z "$version_file" ]]; then
            echo "‚ö†Ô∏è  Nessun file .js corrispondente trovato in $service, salto..."
            continue
          fi

          version=$(grep -oE "MODULE_VERSION *= *['\"]([^'\"]+)['\"]" "$version_file" | head -n1 | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/" | tr -d '\r')

          if [[ -n "$version" ]]; then
            VAR_NAME=$(echo "${name}_version" | tr '[:lower:]' '[:upper:]')
            echo "${VAR_NAME}=${version}" >> .env
            echo "‚úÖ Aggiunto ${VAR_NAME}=${version}"
          else
            echo "‚ö†Ô∏è  Versione non trovata in $version_file, salto..."
          fi
        done

        echo "‚úÖ File .env generato:"
        cat .env

    - name: Copy .env to server
      run: |
        scp -o StrictHostKeyChecking=no .env $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/.env

    - name: Deploy updated DB
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST "ENV_NAME=${{ github.ref_name }} GH_TOKEN=${GH_TOKEN} bash -s" <<'EOF'
          mkdir -p ~/deploy
          cd ~/deploy
          echo "üì• Scarico docker-compose.yml..."
          curl -s -H "Authorization: token $GH_TOKEN" -o docker-compose.yml https://raw.githubusercontent.com/expovin/trading-system/refs/heads/PAPER/docker-compose.yml

          echo "üì• Scarico db_update.sql..."
          curl -H "Authorization: token $GH_TOKEN" -s -o db_update.sql https://raw.githubusercontent.com/expovin/trading-system/refs/heads/PAPER/db/db_update.sql

          if ! grep -q "services:" docker-compose.yml; then
            echo "‚ùå docker-compose.yml non valido o non trovato!"
            cat docker-compose.yml
            exit 1
          fi

          LOWER_PROJECT_NAME=$(echo "$ENV_NAME" | tr '[:upper:]' '[:lower:]')
          echo "Environment: $ENV_NAME"
          echo "GitHub Token Length: ${#GH_TOKEN}"
          echo "Project Name: ${LOWER_PROJECT_NAME}"

          docker compose -p "$LOWER_PROJECT_NAME" down
          docker compose pull
          docker compose --env-file .env -p "$LOWER_PROJECT_NAME" up -d --remove-orphans mysql

          max_attempts=10
          attempt=1

          echo "‚è≥ Attendo che mysql sia healthy..."
          until docker compose -p "$LOWER_PROJECT_NAME" ps --filter "status=running" | grep mysql | grep healthy; do
            if [ $attempt -ge $max_attempts ]; then
              echo "‚ùå ${CONTAINER} non √® diventato healthy dopo ${max_attempts} tentativi. Interrompo."
              exit 1
            fi
            echo "‚åõ ${CONTAINER} non ancora pronto, tentativo ${attempt}/${max_attempts}, riprovo tra 2s..."
            sleep 2
            ((attempt++))
          done
          echo "‚úÖ mysql √® healthy" 
        EOF

    - name: Copy DB migration scripts to server
      run: |
        scp -o StrictHostKeyChecking=no -r db apply-db-updates.sh apply-db-decision.sh $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/

    - name: Run DB migrations on server
      id: prepare
      run: |
        set +e
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << EOF
          cd ~/deploy
          bash apply-db-updates.sh ${{ github.ref_name }}
          STATUS=\$?
          echo "apply db exited with STATUS: $STATUS"
          if [[ \$STATUS -eq 0 ]]; then
            echo "‚úÖ Migrazione riuscita. Pulizia backup..."
            bash apply-db-decision.sh OK
          else
            echo "‚ùå Errore durante la migrazione. Ripristino backup..."
            bash apply-db-decision.sh KO
            exit 1
          fi
          
        EOF

    - name: Crea shared cache volume se non esistente
      if: false
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST <<EOF
          if ! docker volume ls --format '{{.Name}}' | grep -q '^shared_cache_data$'; then
            echo "üõ†Ô∏è  Creo volume condiviso shared_cache_data..."
            docker volume create shared_cache_data
          else
            echo "‚úÖ Volume shared_cache_data gi√† esistente, proseguo..."
          fi
        EOF

    - name: Start all other container
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST "ENV_NAME=${{ github.ref_name }} bash -s" <<'EOF'
          cd ~/deploy
          LOWER_PROJECT_NAME=$(echo "$ENV_NAME" | tr '[:upper:]' '[:lower:]')
          docker compose --env-file .env -p "$LOWER_PROJECT_NAME" up -d --remove-orphans --no-recreate
          docker image prune -a -f
        EOF

    - name: Cleanup .env on server
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << 'EOF'
          rm -f /home/$GCP_USER/deploy/.env
        EOF