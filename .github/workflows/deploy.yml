name: CI/CD for PAPER Branch

on:
  push:
    branches:
      - PAPER
      - LIVE

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  GCP_HOST: ${{ secrets.GCP_HOST }}
  GCP_USER: ${{ secrets.GCP_USER }}
  GH_TOKEN: ${{ secrets.GH_TOKEN }}
  SKIP_PUSH: false
  CREATE_RELEASE: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        clean: true
        fetch-depth: 1

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKERHUB_USERNAME }}
        password: ${{ env.DOCKERHUB_TOKEN }}

    - name: üö¶ Verifica modalit√† di deploy su LIVE
      run: |
        BRANCH_NAME="${{ github.ref_name }}"
        EVENT_NAME="${{ github.event_name }}"
        SOURCE_BRANCH="${{ github.event.pull_request.head.ref }}"
        TARGET_BRANCH="${{ github.event.pull_request.base.ref }}"

        echo "üîç Branch: $BRANCH_NAME, Evento: $EVENT_NAME, PR Source: $SOURCE_BRANCH, PR Target: $TARGET_BRANCH"

        if [[ "$BRANCH_NAME" == "LIVE" ]]; then
          if [[ "$EVENT_NAME" != "pull_request" ]]; then
            echo "‚ùå Deploy su LIVE permesso solo tramite Pull Request da PAPER"
            exit 1
          fi

          if [[ "$SOURCE_BRANCH" != "PAPER" || "$TARGET_BRANCH" != "LIVE" ]]; then
            echo "‚ùå Solo PR da PAPER a LIVE sono consentite"
            exit 1
          fi
        fi

        echo "‚úÖ Controllo superato, proseguo con il deploy..."

    - name: Build and push all Docker images
      run: |
        if [[ "${{ github.ref_name }}" == "LIVE" ]]; then
          echo "‚ö†Ô∏è  Skip build e push: il branch LIVE deve solo eseguire il deploy di immagini gi√† pubblicate."
          exit 0
        fi

        services=(
          DBManager
          cacheManager
          capitalManager
          alertingService
          strategyUtils
          LiveMarketListener
          orderListner
          orderSimulator
          MarketSimulator
          strategies/sma
          strategies/sltp
          scheduler
          tickerScanner
        )

        for service in "${services[@]}"; do
          name=$(basename "$service" | tr '[:upper:]' '[:lower:]')
          RELEASE_FILE="$service/release.json"

          if [[ ! -f "$service/Dockerfile" ]]; then
            echo "‚ö†Ô∏è  Nessun Dockerfile per $service, salto build/push..."
            continue
          fi

          VERSION=""
          if [[ -f "$RELEASE_FILE" ]]; then
            VERSION=$(grep -oE '"version"[[:space:]]*:[[:space:]]*"([^"]+)"' "$RELEASE_FILE" | head -n1 | sed -E 's/.*"version"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/')
          else
            echo "‚ö†Ô∏è  $RELEASE_FILE non trovato per $service, user√≤ solo :latest"
          fi

          if [[ -z "$VERSION" ]]; then
            echo "üè∑  Nessuna versione specifica per $name ‚Üí tag solo :latest"
            TAG_ARGS=( --tag "$DOCKERHUB_USERNAME/$name:latest" )
          else
            echo "üè∑  Versione per $name: $VERSION (user√≤ :$VERSION e :latest)"
            TAG_ARGS=( --tag "$DOCKERHUB_USERNAME/$name:latest" --tag "$DOCKERHUB_USERNAME/$name:$VERSION" )
          fi

          echo "üîß Building $name da directory $service..."

          if [ "$SKIP_PUSH" != "true" ]; then
            docker buildx build --platform linux/amd64 --push "${TAG_ARGS[@]}" --cache-from=type=registry,ref=$DOCKERHUB_USERNAME/$name:cache --cache-to=type=registry,ref=$DOCKERHUB_USERNAME/$name:cache,mode=max -f "$service/Dockerfile" .
          fi
        done



    - name: Setup SSH key
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Creazione release su github
      run: |
        if [ "${{ github.ref_name }}" == "LIVE" ] && [ "$CREATE_RELEASE" != "false" ]; then
          TAG=$(jq -r .version release.json)
          TITLE=$(jq -r .note release.json)

          # Genera le note
          bash ./generate-release-notes.sh

          # Crea la release (gh CLI deve essere installata)
          gh release create "$TAG" \
            --title "$TITLE" \
            --notes-file release-notes.md \
            --target PAPER \
            --repo $GITHUB_REPOSITORY
          else
            echo "üö´ Skip: Creazione release abilitata solo su LIVE o CREATE_RELEASE=false"
          fi

    - name: Generate .env for server
      run: |
        echo "LOG_LEVEL=${{ vars.LOG_LEVEL }}" > .env
        echo "ENV_NAME=${{ github.ref_name }}" >> .env
        echo "LETSENCRYPT_EMAIL=${{ github.LETSENCRYPT_EMAIL }}" >> .env
        echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
        echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
        echo "MYSQL_DATABASE=${{ vars.MYSQL_DATABASE }}" >> .env
        echo "MYSQL_USER=${{ vars.MYSQL_USER }}" >> .env
        echo "MYSQL_HOST=${{vars.MYSQL_HOST}}" >> .env
        echo "ALPACA_MARKET_FEED=${{ vars.ALPACA_MARKET_FEED }}" >> .env
        echo "ENV_MARKET=${{ vars.ENV_MARKET }}" >> .env
        echo "ENV_ORDERS=${{ vars.ENV_ORDERS }}" >> .env
        echo "ENV_TRADING=${{ vars.ENV_TRADING }}" >> .env
        echo "NETWORK=${{ vars.NETWORK }}" >> .env
        echo "ENABLE_DB_LOG=${{ vars.ENABLE_DB_LOG }}" >> .env
        echo "DBMANAGER_VERSION=${{ vars.DBMANAGER_VERSION }}" >> .env
        echo "CACHEMANAGER_VERSION=${{ vars.CACHEMANAGER_VERSION }}" >> .env
        echo "CAPITALMANAGER_VERSION=${{ vars.CAPITALMANAGER_VERSION }}" >> .env
        echo "ALERTINGSERVICE_VERSION=${{ vars.ALERTINGSERVICE_VERSION }}" >> .env
        echo "LIVEMARKETLISTENER_VERSION=${{ vars.LIVEMARKETLISTENER_VERSION }}" >> .env
        echo "ORDERLISTNER_VERSION=${{ vars.ORDERLISTNER_VERSION }}" >> .env
        echo "STRATEGYUTILS_VERSION=${{ vars.STRATEGYUTILS_VERSION }}" >> .env
        echo "TICKERSCANNER_VERSION=${{ vars.TICKERSCANNER_VERSION }}" >> .env
        echo "SCHEDULER_VERSION=${{ vars.SCHEDULER_VERSION }}" >> .env
        echo "SMA_VERSION=${{ vars.SMA_VERSION }}" >> .env
        echo "SLTP_VERSION=${{ vars.SLTP_VERSION }}" >> .env
        echo "MYSQL_PORT=${{vars.MYSQL_PORT}}" >> .env
        echo "APCA_API_KEY_ID=${{secrets.APCA_API_KEY_ID}}" >> .env
        echo "APCA_API_SECRET_KEY=${{secrets.APCA_API_SECRET_KEY}}" >> .env
        echo "FMP_API_KEY=${{secrets.FMP_API_KEY}}" >> .env
        echo "MARKETSIMULATOR_VERSION=${{vars.MARKETSIMULATOR_VERSION}}" >> .env
        echo "ORDERSIMULATOR_VERSION=${{vars.ORDERSIMULATOR_VERSION}}" >> .env
        echo "DBMANAGER_URL=${{vars.DBMANAGER_URL}}" >> .env
        echo "SMA_URL=${{vars.SMA_URL}}" >> .env
        echo "SLTP_URL=${{vars.SLTP_URL}}" >> .env
        echo "CAPITAL_MANAGER_URL=${{vars.CAPITAL_MANAGER_URL}}" >> .env
        echo "ALERTINGMANAGER_URL=${{vars.ALERTINGMANAGER_URL}}" >> .env
        echo "CACHEMANAGER_URL=${{vars.CACHEMANAGER_URL}}" >> .env
        echo "REDIS_URL=${{vars.REDIS_URL}}" >> .env
        echo "LIVEMARKETMANAGER_URL=${{vars.LIVEMARKETMANAGER_URL}}" >> .env
        echo "MARKETSIMULATOR_URL=${{vars.MARKETSIMULATOR_URL}}" >> .env
        echo "SCHEDULER_URL=${{vars.SCHEDULER_URL}}" >> .env
        echo "TICKERSCANNER_URL=${{vars.TICKERSCANNER_URL}}" >> .env

    - name: Add .env with container versions from JS files
      run: |
        echo "üìù Genero .env con le versioni dei container dai file .js..."

        for service in DBManager cacheManager capitalManager alertingService LiveMarketListener orderListner orderSimulator MarketSimulator strategies/sma strategies/sltp; do
          name=$(basename "$service" | tr '[:upper:]' '[:lower:]')

          version_file=$(find "$service" -type f -name "*.js" | while read -r f; do
            file_base=$(basename "$f" .js | tr '[:upper:]' '[:lower:]')
            if [[ "$file_base" == "$name" ]]; then
              echo "$f"
              break
            fi
          done)

          if [[ -z "$version_file" ]]; then
            echo "‚ö†Ô∏è  Nessun file .js corrispondente trovato in $service, salto..."
            continue
          fi

          version=$(grep -oE "MODULE_VERSION *= *['\"]([^'\"]+)['\"]" "$version_file" | head -n1 | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/" | tr -d '\r')

          if [[ -n "$version" ]]; then
            VAR_NAME=$(echo "${name}_version" | tr '[:lower:]' '[:upper:]')
            echo "${VAR_NAME}=${version}" >> .env
            echo "‚úÖ Aggiunto ${VAR_NAME}=${version}"
          else
            echo "‚ö†Ô∏è  Versione non trovata in $version_file, salto..."
          fi
        done

        echo "‚úÖ File .env generato:"
        cat .env

    - name: Copy .env to server
      run: |
        scp -o StrictHostKeyChecking=no .env $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/.env

    - name: Copy DB restore script and dump to server
      run: |
        TAR_FILE=$(ls db/Trading_${{ github.ref_name }}_*.tar.gz 2>/dev/null | head -n 1)
        if [[ -z "$TAR_FILE" ]]; then
          echo "‚ùå Nessun file db/Trading_${{ github.ref_name }}_*.tar.gz trovato"
          exit 1
        fi
        echo "üì¶ Tarball trovato: $TAR_FILE"

        scp -o StrictHostKeyChecking=no \
          restore-env-db.sh \
          "$TAR_FILE" \
          $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/

    - name: Restore DB on server
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST "ENV_NAME=${{ github.ref_name }} bash -s" <<'EOF'
          cd ~/deploy

          # carico le variabili MYSQL_* da .env
          set -a
          . .env
          set +a

          TAR_FILE=$(ls Trading_${ENV_NAME}_*.tar.gz 2>/dev/null | head -n 1)
          if [[ -z "$TAR_FILE" ]]; then
            echo "‚ùå Nessun file Trading_${ENV_NAME}_*.tar.gz trovato per il restore"
            exit 1
          fi

          MARKER_FILE=".last_db_restore_${ENV_NAME}.txt"

          if [[ -f "$MARKER_FILE" ]]; then
            LAST_RESTORED=$(cat "$MARKER_FILE")
          else
            LAST_RESTORED=""
          fi

          echo "üì¶ Dump corrente : $TAR_FILE"
          echo "üìù Ultimo import : ${LAST_RESTORED:-<none>}"

          if [[ "$TAR_FILE" == "$LAST_RESTORED" ]]; then
            echo "‚úÖ Il dump √® lo stesso dell'ultimo restore. Skip ripristino DB."
            exit 0
          fi

          echo "‚ôªÔ∏è Ripristino DB Trading_${ENV_NAME} da $TAR_FILE"
          bash restore-env-db.sh "$ENV_NAME" "$TAR_FILE"

          if [[ $? -eq 0 ]]; then
            echo "$TAR_FILE" > "$MARKER_FILE"
            echo "üìù Aggiornato marker di ultimo restore: $MARKER_FILE"
          else
            echo "‚ùå Errore nel restore, marker NON aggiornato."
            exit 1
          fi
        EOF

    - name: Copy deploy-with-profiles.sh to server
      run: |
        scp -o StrictHostKeyChecking=no \
          deploy-with-profiles.sh \
          $GCP_USER@$GCP_HOST:/home/$GCP_USER/deploy/deploy-with-profiles.sh

        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << 'EOF'
          cd ~/deploy
          chmod +x deploy-with-profiles.sh
        EOF


    - name: Start all other container
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST "ENV_NAME=${{ github.ref_name }} bash -s" <<'EOF'
          cd ~/deploy

          LOWER_PROJECT_NAME=$(echo "$ENV_NAME" | tr '[:upper:]' '[:lower:]')

          # seleziona il compose corretto in base al branch
          COMPOSE_FILE="docker-compose.${ENV_NAME,,}.yml"

          if [ ! -f "$COMPOSE_FILE" ]; then
            echo "‚ùå File $COMPOSE_FILE non trovato!"
            exit 1
          fi

          if [ ! -f "./deploy-with-profiles.sh" ]; then
            echo "‚ùå Script deploy-with-profiles.sh non trovato in ~/deploy!"
            exit 1
          fi

          echo "‚ñ∂Ô∏è Avvio microservizi dinamici per ambiente $ENV_NAME usando profili dal DB"

          #  1. legge i microservizi ON dal DB
          #  2. calcola COMPOSE_PROFILES
          #  3. esegue docker compose up con i profili corretti
          ./deploy-with-profiles.sh "$ENV_NAME" "$COMPOSE_FILE" ".env"

          echo "üßπ Pulizia immagini Docker"
          docker image prune -a -f
        EOF


    - name: Cleanup .env on server
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << EOF
          rm -f /home/$GCP_USER/deploy/.env
        EOF

    - name: Crea shared cache volume se non esistente
      if: false
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST <<EOF
          if ! docker volume ls --format '{{.Name}}' | grep -q '^shared_cache_data$'; then
            echo "üõ†Ô∏è  Creo volume condiviso shared_cache_data..."
            docker volume create shared_cache_data
          else
            echo "‚úÖ Volume shared_cache_data gi√† esistente, proseguo..."
          fi
        EOF

    - name: Start all other container
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST "ENV_NAME=${{ github.ref_name }} bash -s" <<'EOF'
          cd ~/deploy
          LOWER_PROJECT_NAME=$(echo "$ENV_NAME" | tr '[:upper:]' '[:lower:]')
          docker compose -f "docker-compose.${ENV_NAME,,}.yml" -f docker-compose.build.yml --env-file .env -p "$LOWER_PROJECT_NAME" up -d --remove-orphans --no-recreate
          docker image prune -a -f
        EOF

    - name: Cleanup .env on server
      run: |
        ssh -o StrictHostKeyChecking=no $GCP_USER@$GCP_HOST << 'EOF'
          rm -f /home/$GCP_USER/deploy/.env
        EOF
